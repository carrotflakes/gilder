use std::{
    io::{BufRead, Seek, Write},
    sync::Mutex,
};

#[macro_export]
macro_rules! assert_golden {
    ($actual:expr) => {
        let path = file!();
        ::gilder::assert_impl(path, $actual)
    };
}

pub fn assert_impl<T: ToString>(path: &str, actual: T) {
    let mode = get_mode();
    let actual = actual.to_string();
    let file_path = std::path::Path::new(path).with_extension("rs.gld");

    if mode == Mode::Create {
        create_golden_file(&file_path, actual);
    } else {
        let Ok(file) = std::fs::File::open(&file_path) else {
            if mode == Mode::Verify {
                panic!("golden file not found");
            } else {
                // Turn on create mode
                std::env::set_var(ENV_MODE, "create");
                create_golden_file(&file_path, actual);
                return;
            }
        };
        if mode == Mode::Auto {
            std::env::set_var(ENV_MODE, "verify");
        }
        let reader = std::io::BufReader::new(file);
        let index = next_index(path);
        let expect = reader.lines().skip(2 + index).next().unwrap().unwrap();
        assert_eq!(expect, format!("{:?}", actual));
    }
}

#[derive(Debug, PartialEq, Eq)]
enum Mode {
    Create,
    Verify,
    Auto,
}

fn get_mode() -> Mode {
    let mode = std::env::var(ENV_MODE).unwrap_or("auto".to_string());
    match mode.as_str() {
        "create" => Mode::Create,
        "verify" => Mode::Verify,
        "auto" => Mode::Auto,
        _ => panic!("invalid mode"),
    }
}

const ENV_MODE: &str = "GILDER_MODE";

fn create_golden_file(path: &std::path::PathBuf, actual: String) {
    let mut file = open_golden_file_for_create(&path).unwrap();
    writeln!(file, "{:?}", actual).unwrap();
}

fn open_golden_file_for_create(path: &std::path::PathBuf) -> Result<std::fs::File, String> {
    let id = get_id();
    let file = std::fs::OpenOptions::new()
        .read(true)
        .write(true)
        .create(true)
        .open(path)
        .map_err(|e| e.to_string())?;
    let mut reader = std::io::BufReader::new(file);
    let mut buf = String::new();
    reader.read_line(&mut buf).map_err(|e| e.to_string())?;
    if !buf.is_empty() {
        assert!(buf.starts_with(GOLDEN_FILE_HEADER), "invalid golden file");
        buf.clear();
        reader.read_line(&mut buf).map_err(|e| e.to_string())?;
        if buf.trim_end() == format!("{}", id) {
            return Ok(reader.into_inner());
        }
    }

    let mut file = reader.into_inner();
    file.set_len(0).map_err(|e| e.to_string())?;
    file.flush().map_err(|e| e.to_string())?;
    file.seek(std::io::SeekFrom::Start(0))
        .map_err(|e| e.to_string())?;

    writeln!(file, "{}", GOLDEN_FILE_HEADER).map_err(|e| e.to_string())?;
    writeln!(file, "{}", id).map_err(|e| e.to_string())?;
    Ok(file)
}

const GOLDEN_FILE_HEADER: &str = "# This file is generated by gilder. Do not edit it manually.";

/// Identifier for the current run.
static ID: Mutex<Option<u128>> = Mutex::new(None);

fn get_id() -> u128 {
    let mut id = ID.lock().unwrap();
    if id.is_none() {
        id.replace(
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_nanos(),
        );
    }
    id.unwrap()
}

static COUNTERS: Mutex<Vec<(String, usize)>> = Mutex::new(Vec::new());

pub fn next_index(name: &str) -> usize {
    let mut counters = COUNTERS.lock().unwrap();
    if let Some((_, count)) = counters.iter_mut().find(|(n, _)| n == name) {
        *count += 1;
        *count
    } else {
        counters.push((name.to_string(), 0));
        0
    }
}
