use std::{
    io::{BufRead, Seek, Write},
    sync::Mutex,
};

#[macro_export]
macro_rules! assert_golden {
    ($actual:expr) => {
        let path = $crate::__get_absolute_path(env!("CARGO_MANIFEST_DIR"), file!());
        $crate::assert_impl(path, $actual)
    };
}

pub fn assert_impl<T: ToString>(path: std::path::PathBuf, actual: T) {
    let mode = get_mode();
    let actual = actual.to_string();
    let file_path = path.with_extension("rs.gld");

    if mode == Mode::Create {
        create_golden_file(&file_path, actual);
    } else {
        let Ok(file) = std::fs::File::open(&file_path) else {
            if mode == Mode::Verify {
                panic!("golden file not found");
            } else {
                // Turn on create mode
                std::env::set_var(ENV_MODE, "create");
                create_golden_file(&file_path, actual);
                return;
            }
        };
        if mode == Mode::Auto {
            std::env::set_var(ENV_MODE, "verify");
        }
        let reader = std::io::BufReader::new(file);
        let index = next_index(path);
        let expect = reader
            .lines()
            .skip(2 + index)
            .next()
            .expect("End of golden file. If you want to add a new test case, please regenerate the golden file.")
            .unwrap();
        if expect != format!("{:?}", actual) {
            panic!(
                r#"assertion failed: The given value differs from the previous value (from the golden file).
  actual: `{:?}`,
  expect: `{:?}`"#,
                actual, expect
            )
        }
    }
}

#[derive(Debug, PartialEq, Eq)]
enum Mode {
    Create,
    Verify,
    Auto,
}

fn get_mode() -> Mode {
    let mode = std::env::var(ENV_MODE).unwrap_or("auto".to_string());
    match mode.as_str() {
        "create" => Mode::Create,
        "verify" => Mode::Verify,
        "auto" => Mode::Auto,
        _ => panic!("invalid mode"),
    }
}

const ENV_MODE: &str = "GILDER_MODE";

fn create_golden_file(path: &std::path::PathBuf, actual: String) {
    let mut file = open_golden_file_for_create(&path).unwrap();
    writeln!(file, "{:?}", actual).unwrap();
}

fn open_golden_file_for_create(path: &std::path::PathBuf) -> Result<std::fs::File, String> {
    let id = get_id();
    let file = std::fs::OpenOptions::new()
        .read(true)
        .write(true)
        .create(true)
        .open(path)
        .map_err(|e| e.to_string())?;
    let mut reader = std::io::BufReader::new(file);
    let mut buf = String::new();
    reader.read_line(&mut buf).map_err(|e| e.to_string())?;
    if !buf.is_empty() {
        assert!(buf.starts_with(GOLDEN_FILE_HEADER), "invalid golden file");
        buf.clear();
        reader.read_line(&mut buf).map_err(|e| e.to_string())?;
        if buf.trim_end() == format!("{}", id) {
            return Ok(reader.into_inner());
        }
    }

    let mut file = reader.into_inner();
    file.set_len(0).map_err(|e| e.to_string())?;
    file.flush().map_err(|e| e.to_string())?;
    file.seek(std::io::SeekFrom::Start(0))
        .map_err(|e| e.to_string())?;

    writeln!(file, "{}", GOLDEN_FILE_HEADER).map_err(|e| e.to_string())?;
    writeln!(file, "{}", id).map_err(|e| e.to_string())?;
    Ok(file)
}

const GOLDEN_FILE_HEADER: &str = "# This file is generated by gilder. Do not edit it manually.";

/// Identifier for the current run.
static ID: Mutex<Option<u128>> = Mutex::new(None);

fn get_id() -> u128 {
    let mut id = ID.lock().unwrap();
    if id.is_none() {
        id.replace(
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_nanos(),
        );
    }
    id.unwrap()
}

static COUNTERS: Mutex<Vec<(std::path::PathBuf, usize)>> = Mutex::new(Vec::new());

fn next_index(name: std::path::PathBuf) -> usize {
    let mut counters = COUNTERS.lock().unwrap();
    if let Some((_, count)) = counters.iter_mut().find(|(n, _)| n == &name) {
        *count += 1;
        *count
    } else {
        counters.push((name, 0));
        0
    }
}

pub fn __get_absolute_path(manifest_dir: &str, file: &str) -> std::path::PathBuf {
    let manifest_dir = std::path::Path::new(manifest_dir);
    let file = std::path::Path::new(file);

    let abs = manifest_dir.join(file);
    if abs.exists() {
        return abs;
    }

    // Search for the file in the parent directories
    let mut dir = manifest_dir;
    loop {
        dir = match dir.parent() {
            Some(dir) => dir,
            None => panic!("not found: {}", file.display()),
        };
        let abs = dir.join(file);
        if abs.starts_with(manifest_dir) && abs.exists() {
            return abs;
        }
    }
}
